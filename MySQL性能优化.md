# MySQL性能优化

## 逻辑架构

可以清晰的查找各层次问题，降低工作量，提高问题解决效率。

### 连接层

不同的语言有不同的连接驱动，用于做数据库连接授权认证。

连接池:循环利用连接，提高性能，创建连接比较耗费性能，所以，数据库，FTP等等都应该有连接池，缓存的概念不外如是。

### 服务层

服务管理，安全，备份，复制，集群等，都属于这个模块。

操作数据库，增删改查，事务，视图等操作。

内部自带优化器，缓存等。

### 引擎层

存储引擎，最常用的有MyISAM，InnoDB

innodb中只能使用BTREE作为索引类型

MyISAM中只能使用HASH作为索引类型

### 存储层

存储与磁盘



## 存储引擎

采用不同的技术存储文件与数据，就形成了各种存储引擎。

show engines   -----查看存储引擎

列：

​	内存：速度快，但不能长期保存。

​	磁盘：相对较慢，但能长期保存。

### MyISAM与InnoDb

0：不支持

1：支持

|   功能   |                            MyISAM                            |                            InnoDB                            |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|  主外键  |                              0                               |                              1                               |
|   事务   |                              0                               |                              1                               |
|   行锁   |                              0                               |                              1                               |
|   表锁   |                              1                               |                              0                               |
|   缓存   |                    只缓存索引，不缓存数据                    |              对索引和数据都做缓存，内存消耗较大              |
|  表空间  |                              小                              |                              小                              |
|  关注点  |                             性能                             |                         相对下降一些                         |
| 默认安装 |                              1                               |                              1                               |
| 文件结构 | b.frm:描述表结构，字段长度<br />b.MYD(MYData):数据信息文件，存储数据信息(如果采用独立表存储模式)<br />b.MYI(MYIndex):索引信息文件 | b.frm:描述表结构，字段长度等。<br />b.ibd:存储数据信息和索引信息。 |

## SQL的执行顺序

### 代码编写顺序

```mermaid
graph LR
A[操作符]-->B[选择字段]
B-->C[选表]
C-->D[连接的表]
D-->E[on条件]
E-->F[字段条件]
F-->G[分组]
G-->H[排序]
H-->J[limit]
```

### MySQL读取顺序

```mermaid
graph LR
A[选表]-->B[on条件]
B-->C[连接的表]
C-->D[字段条件]
D-->E[分组]
E-->F[操作符]
F-->G[选择字段]
G-->H[排序]
H-->J[limit]
```

### 整体过程

1. 先对多表进行关系，更具条件找出符合条件的记录。

2. 在符合条件的基础上进行再次where条件筛选

3. 对筛选出来的内容进行分组操作。

4. 分组完成后，使用还having再次筛选出瞒住条件的记录。

5. 取所满足条件的记录。

6. 对取出的记录进行排序

7. 最终从取出的记录当中获取多少条记录显示出来。

## 链接查询

### 内链接

inner join

查询表的公有数据（公共字段）。

### 左右链接

left join

right join

取出左边或者右边的所有数据，再取出另一边符合条件的数据。

### 查询独有数据

数据基础上加上条件。

is null

is not null

### 全连接

俩表全部的信息。

Oracle中支持Full Outter,MySQL中不支持。

使用unio,把左右链接合并起来

```sql
select * A a left join B b on a.id = b.id
union
select * A a right join B b on a.id = b.id
```

查询两张表独有的数据也差不多，只需要查询每张表独有的数据即可。

## 优化分析

### 性能下降原因

执行时间变长，等待时间变长时，数据越多越明显，就是sql性能正在下降，应及时做出处理。

原因有几点：

- 语句问题：连接过多，子查询过多，导致没有用上索引

- 无效索引：建立索引后没有加以利用

- 使用过多join：和for嵌套类似，复杂度会变高

- 服务器配置：服务器配置和调优不合理，会导致各种情况，可以在服务器上和远程连接上执行相同sql做对比

### 解决概论

学习高质量sql，深入理解索引，保证在建立合理索引，使用索引时不失效。

合理利用引擎。

程序端不要使用太多重复的sql，尽量与传值方式或者引用方式使用。

合理使用缓存。

## 索引

### 索引概论

频繁查询，但相对较少更新可做索引。

索引往往以文件形式存储到磁盘上，索引也是一张表，保存了主键与索引字段。

为了加快数据的查找，可以维护二叉树，每个节点分别包含索引键值和一个指向对应数据记录的物理地址的指针，但最终还是使用的B+树。

#### 优势

- 一种数据结构，帮助mysql高效获取数据。
- 可以理解成字典。
- 排序，快速定位查找
- 提高效率，降低数据库IO成本，降低排序成本，降低CPU消耗。

#### 劣势

- 索引会导致插入更新变慢（会更新索引）
- 需要占用磁盘空间（类似动态规划，空间换时间）

### 索引分类

#### 单值索引

某一字段单独设置索引

一张表可以有多个单值索引

一般每张表不超出5个。

#### 唯一索引

每一行都是唯一，不能有重复的值

不能为空

主键自动建立唯一索引

#### 符合索引

多个字段关联到一起

#### 全文索引

字段内文字比较多，想使用关键字和列内容之间的相关度进行检索，可以利用全文索引来提高匹配的速度。

### 索引使用

查看表索引：show index from 表

#### 创建索引

create index `名称` on `表(字段)`

